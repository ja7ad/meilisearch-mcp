package protocol

import (
	"context"
	"time"

	"github.com/bytedance/sonic"
	"github.com/mark3labs/mcp-go/mcp"
	"github.com/mark3labs/mcp-go/server"
	"github.com/meilisearch/meilisearch-go"
)

func (p *Protocol) ListKeys() (tool mcp.Tool, handler server.ToolHandlerFunc) {
	return mcp.NewTool("list_keys",
			mcp.WithDescription("List all API keys in Meilisearch"),
			WithPagination(),
		), func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			limit, err := OptionalInt64Param(req, "limit")
			if err != nil {
				return mcp.NewToolResultError(err.Error()), nil
			}

			offset, err := OptionalInt64Param(req, "offset")
			if err != nil {
				return mcp.NewToolResultError(err.Error()), nil
			}

			client, err := p.client(req.Header)
			if err != nil {
				return mcp.NewToolResultError(err.Error()), nil
			}

			if limit <= 0 {
				limit = 20 // Default limit if not specified
			}

			if offset <= 0 {
				offset = 0 // Default offset if not specified
			}

			resp, err := client.GetKeysWithContext(ctx, &meilisearch.KeysQuery{
				Limit:  limit,
				Offset: offset,
			})
			if err != nil {
				return mcp.NewToolResultError(err.Error()), nil
			}

			b, err := sonic.Marshal(resp)
			if err != nil {
				return nil, err
			}

			return mcp.NewToolResultText(string(b)), nil
		}
}

func (p *Protocol) GetKey() (tool mcp.Tool, handler server.ToolHandlerFunc) {
	return mcp.NewTool("get_key",
			mcp.WithDescription("Get API key"),
			mcp.WithString("key", mcp.Description("API key")),
			mcp.WithString("uid", mcp.Description("Key UID")),
		), func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			key, err := OptionalParam[string](req, "key")
			if err != nil {
				return mcp.NewToolResultError(err.Error()), nil
			}

			uid, err := OptionalParam[string](req, "uid")
			if err != nil {
				return mcp.NewToolResultError(err.Error()), nil
			}

			if key == "" && uid == "" {
				return mcp.NewToolResultError("API key or UID is required"), nil
			} else if key != "" {
				if err := p.validate(key, "max=250,min=1"); err != nil {
					return mcp.NewToolResultError(err.Error()), nil
				}
			} else if uid != "" {
				if err := p.validate(uid, "max=250,min=1"); err != nil {
					return mcp.NewToolResultError(err.Error()), nil
				}
			}

			client, err := p.client(req.Header)
			if err != nil {
				return mcp.NewToolResultError(err.Error()), nil
			}

			resp, err := client.GetKeyWithContext(ctx, key)
			if err != nil {
				return mcp.NewToolResultError(err.Error()), nil
			}

			b, err := sonic.Marshal(resp)
			if err != nil {
				return nil, err
			}

			return mcp.NewToolResultText(string(b)), nil
		}
}

func (p *Protocol) CreateKey() (tool mcp.Tool, handler server.ToolHandlerFunc) {
	return mcp.NewTool("create_key",
			mcp.WithDescription("Create a new API key"),
			mcp.WithArray("actions", mcp.Description("List of actions the key can perform, for example: [\"documents.add\", \"documents.delete\"]"),
				mcp.Required(),
				mcp.Items(map[string]interface{}{
					"type":     "array",
					"minItems": 1,
					"items": map[string]any{
						"type": "string",
					},
				}),
			),
			mcp.WithArray("indexes",
				mcp.Description("List of indexes the key can access, for example: [\"index1\", \"index2\"]"),
				mcp.Required(),
				mcp.Items(map[string]interface{}{
					"type":     "array",
					"minItems": 1,
					"items": map[string]any{
						"type": "string",
					},
				}),
			),
			mcp.WithString("expire_at",
				mcp.Description("Date and time when the key will expire, represented in RFC 3339 format. null if the key never expires"),
				mcp.Required(),
			),
			mcp.WithString("name",
				mcp.Description("Name of the key (Optional)")),
			mcp.WithString("description",
				mcp.Description("Description of the key (Optional)")),
			mcp.WithString("uid",
				mcp.Description("A uuid v4 to identify the API key. If not specified, it is generated by Meilisearch (Optional)")),
		), func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			actions, err := RequiredStringArrayParam(req, "actions")
			if err != nil {
				return mcp.NewToolResultError(err.Error()), nil
			}

			if len(actions) == 0 {
				return mcp.NewToolResultError("actions is required (min:1)"), nil
			}

			indexes, err := RequiredStringArrayParam(req, "indexes")
			if err != nil {
				return mcp.NewToolResultError(err.Error()), nil
			}

			if len(indexes) == 0 {
				return mcp.NewToolResultError("indexes is required (min:1)"), nil
			}

			expireAt, err := RequiredParam[string](req, "expire_at")
			if err != nil {
				return mcp.NewToolResultError(err.Error()), nil
			}

			var expireAtTime time.Time
			if expireAt != "null" {
				if err = p.validate(expireAt, "required"); err != nil {
					return mcp.NewToolResultError(err.Error()), nil
				}

				if expireAtTime, err = time.Parse(time.RFC3339, expireAt); err != nil {
					return mcp.NewToolResultError("expire_at must be in RFC3339 format (e.g., 2042-04-02T00:42:42Z)"), nil
				}
			}

			name, err := OptionalParam[string](req, "name")
			if err != nil {
				return mcp.NewToolResultError(err.Error()), nil
			}

			description, err := OptionalParam[string](req, "description")
			if err != nil {
				return mcp.NewToolResultError(err.Error()), nil
			}

			uid, err := OptionalParam[string](req, "uid")
			if err != nil {
				return mcp.NewToolResultError(err.Error()), nil
			}

			client, err := p.client(req.Header)
			if err != nil {
				return mcp.NewToolResultError(err.Error()), nil
			}

			key := &meilisearch.Key{
				Actions:     actions,
				Indexes:     indexes,
				ExpiresAt:   expireAtTime,
				Name:        name,
				Description: description,
				UID:         uid,
			}

			resp, err := client.CreateKeyWithContext(ctx, key)
			if err != nil {
				return mcp.NewToolResultError(err.Error()), nil
			}

			b, err := sonic.Marshal(resp)
			if err != nil {
				return nil, err
			}
			return mcp.NewToolResultText(string(b)), nil
		}
}
